# JSON

Цель: Научиться работать с JSON, способом представления структурированных данных.


Задание<br/>
×<br/>

Перед описанием задания рассмотрим несколько концепций.

Конфигурация приложения (как существительное) – это различные параметры, которые используются в процессе работы, например, логины, пароли, ключи к другим системам и внешним сервисам, адреса, квоты и тому подобные вещи.

Конфигурация бывает статической (файл с настройками) или динамической. Динамическую конфигурацию, обычно, хранят в системах, подобных consul. Это такая распределенная key-value база данных с кучей плюшек.

key-value означает что эта база данных подобна словарю. В нее можно записать значение по определенному ключу, и прочитать это же значение (или перезаписать ее). Основной интерфейс состоит из двух функций set(key, value) и get(key). На практике такая база, обычно, предоставляет простой HTTP-интерфейс, в котором GET запрос извлекает данные по ключу, а POST устанавливает значение.

Под распределенностью понимается то что она автоматически синхронизируется между всеми нодами (машинами, серверами) кластера (группа серверов). То есть, если вы делаете изменение в локальной версии базы для конкретного сервера, то через некоторый, как правило, очень короткий промежуток времени, это же значение появиться и на всех остальных машинах кластера.

Главная идея в том, что конфигурация обновляется (разными способами) и постоянно актуализируется, а приложение каждый раз обращается к этому сервису для получения последних данных.

В текущем уроке мы будем использовать такой сервис для определения списка урлов, по которым располагается сайт.

// Обращение к консулу для извлечения значения по ключу 'backends'<br/>
get(`http://localhost:5456/backends`);<br/>
Запрос возвращает json следующей структуры:

[<br/>
  {<br/>
    "url": "http://ru.hexlet.io",<br/>
    "lang": "ru"<br/>
  }, {<br/>
    "url": "http://en.hexlet.io",<br/>
    "lang": "en"<br/>
  }, {<br/>
    "url": "http://gr.hexlet.io",<br/>
    "lang": "gr"<br/>
  }<br/>
]<br/>
Как видно из структуры, у хекслета есть языковые версии сайтов и их список лежит в консуле под ключем backends.

Сама задача заключается в следующем. На воображаемом сервисе, который мы разрабатываем, появилась задача определять самый незагруженный поддомен (подразумевается, что каждый поддомен обслуживается на своем сервере) и обновлять его в консуле с некоторой периодичностью.

Процесс описывается следующим алгоритмом:

Делаем запрос в consul на чтение значения ключа backends и извлекаем список адресов<br/>
Делаем запрос ко всем серверам на статусную страницу (адрес строится так: ${url}/status) для домена ru.hexlet.io это будет ru.hexlet.io/status.<br/>
Находим самый незагруженный сервер.<br/>
Обновляем запись в consul.<br/>
Запрос на статусную страницу возвращает данные в виде json:

{<br/>
  "workload": "10",<br/>
  "url": "http://ru.hexlet.io"<br/>
}<br/>
Параметр workload означает нагрузку на сервер, чем он меньше, тем нагрузка меньше.

Для обновления самого незагруженного поддомена в консуле, необходимо выполнить следующий запрос:

// value - это url самого незагруженного поддомена, взятый из json статусной страницы<br/>
post(setCurrentBackendUrl, { value: url });<br/>
// post('http://localhost:5456/backends/current', { value: url });<br/>
Этот запрос в консул, устанавливает значение { value: url } по ключу backends/current

solution.js<br/>
Реализуйте и экспортируйте по умолчанию функцию, которая обновляет значение по ключу backends/current в consul. Функция принимает на вход два адреса: 1) адрес по которому можно получить список серверов 2) адрес для обновления значения текущего незагруженного поддомена (post запросом).

Функция должна вернуть promise, выполняющий обновление значения по ключу backends/current.

Подсказки

Функции get и post возвращают promise.

89% пользователей решило эту задачу самостоятельно